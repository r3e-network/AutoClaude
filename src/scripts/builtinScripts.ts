/**
 * Built-in scripts for Claude Autopilot
 * These scripts are embedded in the extension and copied to workspace .autopilot folder
 */

import { TDD_AUTOMATION_SCRIPT, AI_CODE_REVIEW_SCRIPT, DOC_GENERATOR_SCRIPT } from './automationScripts';

export const BUILTIN_SCRIPTS = {
    'production-readiness.js': `#!/usr/bin/env node
/**
 * Production Readiness Check
 * Checks for TODO, FIXME, placeholders, and incomplete implementations
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Patterns that indicate incomplete or non-production code
        const patterns = [
            { pattern: /TODO/gi, message: 'TODO comment found' },
            { pattern: /FIXME/gi, message: 'FIXME comment found' },
            { pattern: /PLACEHOLDER/gi, message: 'Placeholder found' },
            { pattern: /XXX/gi, message: 'XXX marker found' },
            { pattern: /HACK/gi, message: 'HACK comment found' },
            { pattern: /temporary/gi, message: 'Temporary code found' },
            { pattern: /quick\\s+fix/gi, message: 'Quick fix found' },
            { pattern: /for\\s+now/gi, message: '"for now" comment found' },
            { pattern: /simplified/gi, message: 'Simplified implementation found' },
            { pattern: /\\.\\.\\./, message: 'Ellipsis (...) found - possible incomplete code' },
            { pattern: /<<<|>>>/, message: 'Merge conflict markers found' },
            { pattern: /not\\s+implemented/gi, message: 'Not implemented found' },
            { pattern: /throw\\s+new\\s+Error\\(['\`]not\\s+implemented/gi, message: 'Not implemented error found' },
            { pattern: /console\\.(log|debug|trace)/g, message: 'Debug console statement found' },
            { pattern: /debugger;/g, message: 'Debugger statement found' }
        ];
        
        // File extensions to check
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.go', '.cpp', '.cc', '.h', '.hpp', '.rs', '.cs', '.java', '.py', '.rb', '.php', '.swift', '.kt', '.scala', '.vue', '.svelte'];
        
        // Directories to skip
        const skipDirs = ['.git', 'node_modules', 'dist', 'build', 'out', 'target', 'bin', 'obj', '.next', '.nuxt', 'coverage', '.nyc_output', 'vendor', '.autopilot'];
        
        function scanDirectory(dir) {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!skipDirs.includes(file) && !file.startsWith('.')) {
                        scanDirectory(filePath);
                    }
                } else if (stat.isFile()) {
                    const ext = path.extname(file);
                    if (extensions.includes(ext)) {
                        checkFile(filePath, patterns);
                    }
                }
            }
        }
        
        function checkFile(filePath, patterns) {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\\n');
            const relativePath = path.relative(process.cwd(), filePath);
            
            patterns.forEach(({ pattern, message }) => {
                lines.forEach((line, index) => {
                    if (pattern.test(line)) {
                        errors.push(\`\${relativePath}:\${index + 1} - \${message}\`);
                    }
                });
            });
            
            // Check for empty catch blocks
            const emptyCatchPattern = /catch\\s*\\([^)]*\\)\\s*{\\s*}/g;
            if (emptyCatchPattern.test(content)) {
                warnings.push(\`\${relativePath} - Empty catch block found\`);
            }
            
            // Check for any(...) type in TypeScript files
            if (ext === '.ts' || ext === '.tsx') {
                const anyTypePattern = /:\\s*any\\b/g;
                const anyMatches = content.match(anyTypePattern) || [];
                if (anyMatches.length > 0) {
                    warnings.push(\`\${relativePath} - Found \${anyMatches.length} uses of 'any' type\`);
                }
            }
        }
        
        // Start scanning from current directory
        scanDirectory(process.cwd());
        
        // Additional checks
        if (errors.length === 0 && warnings.length === 0) {
            console.error('Production readiness check completed successfully');
        }
        
    } catch (error) {
        errors.push(\`Production readiness check failed: \${error.message}\`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(\`Unexpected error during production readiness check: \${error.message}\`);
    console.log(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'build-check.js': `#!/usr/bin/env node
/**
 * Build Check Script
 * Verifies that the project builds successfully
 * Auto-generated by Claude Autopilot
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const projectRoot = process.cwd();
        let buildExecuted = false;
        
        // Check for Node.js project
        if (fs.existsSync(path.join(projectRoot, 'package.json'))) {
            const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));
            
            // Check for build script
            if (packageJson.scripts && packageJson.scripts.build) {
                console.error('Running npm build...');
                try {
                    execSync('npm run build', { encoding: 'utf8', stdio: 'pipe' });
                    buildExecuted = true;
                } catch (error) {
                    errors.push(\`Build failed: \${error.message}\`);
                    buildExecuted = true;
                }
            } else if (packageJson.scripts && packageJson.scripts.compile) {
                console.error('Running npm compile...');
                try {
                    execSync('npm run compile', { encoding: 'utf8', stdio: 'pipe' });
                    buildExecuted = true;
                } catch (error) {
                    errors.push(\`Compile failed: \${error.message}\`);
                    buildExecuted = true;
                }
            } else {
                warnings.push('No build or compile script found in package.json');
            }
        }
        
        // Check for Go project
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, 'go.mod')) || 
                               fs.existsSync(path.join(projectRoot, 'main.go')))) {
            console.error('Running go build...');
            try {
                execSync('go build ./...', { encoding: 'utf8' });
                buildExecuted = true;
            } catch (error) {
                errors.push(\`Go build failed: \${error.message}\`);
                buildExecuted = true;
            }
        }
        
        // Check for Rust project
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            console.error('Running cargo build...');
            try {
                execSync('cargo build', { encoding: 'utf8' });
                buildExecuted = true;
            } catch (error) {
                errors.push(\`Cargo build failed: \${error.message}\`);
                buildExecuted = true;
            }
        }
        
        // Check for .NET/C# project
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, '*.csproj')) || 
                               fs.existsSync(path.join(projectRoot, '*.sln')))) {
            console.error('Running dotnet build...');
            try {
                execSync('dotnet build', { encoding: 'utf8' });
                buildExecuted = true;
            } catch (error) {
                errors.push(\`Dotnet build failed: \${error.message}\`);
                buildExecuted = true;
            }
        }
        
        // Check for Java project (Maven)
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            console.error('Running maven build...');
            try {
                execSync('mvn compile', { encoding: 'utf8' });
                buildExecuted = true;
            } catch (error) {
                errors.push(\`Maven build failed: \${error.message}\`);
                buildExecuted = true;
            }
        }
        
        // Check for Java project (Gradle)
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, 'build.gradle')) || 
                               fs.existsSync(path.join(projectRoot, 'build.gradle.kts')))) {
            console.error('Running gradle build...');
            try {
                execSync('./gradlew build', { encoding: 'utf8' });
                buildExecuted = true;
            } catch (error) {
                errors.push(\`Gradle build failed: \${error.message}\`);
                buildExecuted = true;
            }
        }
        
        if (!buildExecuted) {
            warnings.push('No recognized build system found. Supported: npm, go, cargo, dotnet, maven, gradle');
        }
        
    } catch (error) {
        errors.push(\`Build check failed: \${error.message}\`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(\`Unexpected error during build check: \${error.message}\`);
    console.log(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'test-check.js': `#!/usr/bin/env node
/**
 * Test Check Script
 * Verifies that all tests pass
 * Auto-generated by Claude Autopilot
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const projectRoot = process.cwd();
        let testsExecuted = false;
        
        // Check for Node.js project
        if (fs.existsSync(path.join(projectRoot, 'package.json'))) {
            const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));
            
            // Check for test script
            if (packageJson.scripts && packageJson.scripts.test) {
                console.error('Running npm test...');
                try {
                    // Skip watch mode for CI
                    execSync('npm test -- --watchAll=false --ci', { encoding: 'utf8', stdio: 'pipe' });
                    testsExecuted = true;
                } catch (error) {
                    // Try without CI flags
                    try {
                        execSync('npm test', { encoding: 'utf8', stdio: 'pipe' });
                        testsExecuted = true;
                    } catch (error2) {
                        errors.push(\`Tests failed: \${error2.message}\`);
                        testsExecuted = true;
                    }
                }
            } else {
                warnings.push('No test script found in package.json');
            }
        }
        
        // Check for Go project
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'go.mod')) || 
                               fs.existsSync(path.join(projectRoot, 'main.go')))) {
            console.error('Running go test...');
            try {
                execSync('go test ./...', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Go tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Check for Rust project  
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            console.error('Running cargo test...');
            try {
                execSync('cargo test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Cargo tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Check for .NET/C# project
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, '*.csproj')) || 
                               fs.existsSync(path.join(projectRoot, '*.sln')))) {
            console.error('Running dotnet test...');
            try {
                execSync('dotnet test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Dotnet tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Check for Java project (Maven)
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            console.error('Running maven test...');
            try {
                execSync('mvn test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Maven tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Check for Java project (Gradle)
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'build.gradle')) || 
                               fs.existsSync(path.join(projectRoot, 'build.gradle.kts')))) {
            console.error('Running gradle test...');
            try {
                execSync('./gradlew test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Gradle tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Python - pytest/unittest
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'setup.py')) || 
                               fs.existsSync(path.join(projectRoot, 'pyproject.toml')) ||
                               fs.existsSync(path.join(projectRoot, 'requirements.txt')))) {
            const hasTests = fs.existsSync(path.join(projectRoot, 'tests')) || 
                           fs.existsSync(path.join(projectRoot, 'test'));
            
            if (hasTests) {
                // Try pytest first
                try {
                    console.error('Running pytest...');
                    execSync('pytest', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    // Try unittest
                    try {
                        console.error('Running python unittest...');
                        execSync('python -m unittest discover', { encoding: 'utf8' });
                        testsExecuted = true;
                    } catch (error2) {
                        errors.push(\`Python tests failed: \${error2.message}\`);
                        testsExecuted = true;
                    }
                }
            } else {
                warnings.push('Python project found but no test directory detected');
            }
        }
        
        // Ruby - RSpec/Minitest
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'Gemfile')) || 
                               fs.existsSync(path.join(projectRoot, '.ruby-version')))) {
            const hasSpec = fs.existsSync(path.join(projectRoot, 'spec'));
            const hasTest = fs.existsSync(path.join(projectRoot, 'test'));
            
            if (hasSpec) {
                try {
                    console.error('Running rspec...');
                    execSync('bundle exec rspec', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    errors.push(\`RSpec tests failed: \${error.message}\`);
                    testsExecuted = true;
                }
            } else if (hasTest) {
                try {
                    console.error('Running rake test...');
                    execSync('bundle exec rake test', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    warnings.push('Ruby test directory found but tests failed to run');
                }
            } else {
                warnings.push('Ruby project found but no test directory detected');
            }
        }
        
        if (!testsExecuted) {
            warnings.push('No recognized test framework found. Supported: npm test, jest, mocha, vitest, go test, cargo test, dotnet test, maven test, gradle test, pytest, unittest, rspec, rake test');
        }
        
        // Check for test files even if no runner was found
        if (!testsExecuted) {
            const testPatterns = ['*.test.js', '*.spec.js', '*.test.ts', '*.spec.ts', '*_test.go', '*_test.py', 'test_*.py', '*Test.java', '*Tests.cs'];
            let hasTestFiles = false;
            
            function findTestFiles(dir) {
                try {
                    const files = fs.readdirSync(dir);
                    for (const file of files) {
                        const filePath = path.join(dir, file);
                        const stat = fs.statSync(filePath);
                        
                        if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                            findTestFiles(filePath);
                        } else if (stat.isFile()) {
                            for (const pattern of testPatterns) {
                                if (file.match(pattern.replace('*', '.*'))) {
                                    hasTestFiles = true;
                                    return;
                                }
                            }
                        }
                    }
                } catch (e) {
                    // Ignore permission errors
                }
            }
            
            findTestFiles(projectRoot);
            
            if (hasTestFiles) {
                errors.push('Test files found but no test runner detected or configured');
            }
        }
        
    } catch (error) {
        errors.push(\`Test check failed: \${error.message}\`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(\`Unexpected error during test check: \${error.message}\`);
    console.log(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'format-check.js': `#!/usr/bin/env node
/**
 * Format Check Script
 * Verifies that code is properly formatted
 * Auto-generated by Claude Autopilot
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const projectRoot = process.cwd();
        let formatCheckExecuted = false;
        
        // Check for Node.js project with prettier
        if (fs.existsSync(path.join(projectRoot, 'package.json'))) {
            const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));
            
            // Check for prettier
            const hasPrettier = (packageJson.devDependencies && packageJson.devDependencies.prettier) ||
                              (packageJson.dependencies && packageJson.dependencies.prettier) ||
                              fs.existsSync(path.join(projectRoot, '.prettierrc')) ||
                              fs.existsSync(path.join(projectRoot, '.prettierrc.json')) ||
                              fs.existsSync(path.join(projectRoot, '.prettierrc.js'));
            
            if (hasPrettier) {
                console.error('Running prettier check...');
                try {
                    execSync('npx prettier --check .', { encoding: 'utf8', stdio: 'pipe' });
                    formatCheckExecuted = true;
                } catch (error) {
                    errors.push('Code formatting issues found. Run: npx prettier --write .');
                    formatCheckExecuted = true;
                }
            }
            
            // Check for ESLint
            const hasEslint = (packageJson.devDependencies && packageJson.devDependencies.eslint) ||
                            (packageJson.dependencies && packageJson.dependencies.eslint) ||
                            fs.existsSync(path.join(projectRoot, '.eslintrc')) ||
                            fs.existsSync(path.join(projectRoot, '.eslintrc.json')) ||
                            fs.existsSync(path.join(projectRoot, '.eslintrc.js'));
            
            if (hasEslint && !formatCheckExecuted) {
                console.error('Running eslint check...');
                try {
                    execSync('npx eslint .', { encoding: 'utf8', stdio: 'pipe' });
                    formatCheckExecuted = true;
                } catch (error) {
                    errors.push('Linting issues found. Run: npx eslint --fix .');
                    formatCheckExecuted = true;
                }
            }
        }
        
        // Check for Go project
        if (!formatCheckExecuted && (fs.existsSync(path.join(projectRoot, 'go.mod')) || 
                                    fs.existsSync(path.join(projectRoot, 'main.go')))) {
            console.error('Running gofmt check...');
            try {
                const unformatted = execSync('gofmt -l .', { encoding: 'utf8' }).trim();
                if (unformatted) {
                    errors.push(\`Go files need formatting: \${unformatted.split('\\n').join(', ')}\`);
                }
                formatCheckExecuted = true;
            } catch (error) {
                warnings.push('gofmt check failed');
            }
        }
        
        // Check for Rust project
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            console.error('Running rustfmt check...');
            try {
                execSync('cargo fmt -- --check', { encoding: 'utf8', stdio: 'pipe' });
                formatCheckExecuted = true;
            } catch (error) {
                errors.push('Rust formatting issues found. Run: cargo fmt');
                formatCheckExecuted = true;
            }
        }
        
        // Check for Python project
        if (!formatCheckExecuted && (fs.existsSync(path.join(projectRoot, 'setup.py')) || 
                                    fs.existsSync(path.join(projectRoot, 'pyproject.toml')) ||
                                    fs.existsSync(path.join(projectRoot, 'requirements.txt')))) {
            // Try black
            try {
                console.error('Running black check...');
                execSync('black --check .', { encoding: 'utf8', stdio: 'pipe' });
                formatCheckExecuted = true;
            } catch (error) {
                if (error.message.includes('would reformat')) {
                    errors.push('Python formatting issues found. Run: black .');
                    formatCheckExecuted = true;
                } else {
                    // Black not installed, try autopep8
                    try {
                        console.error('Running autopep8 check...');
                        const result = execSync('autopep8 --diff -r .', { encoding: 'utf8' });
                        if (result.trim()) {
                            errors.push('Python formatting issues found. Run: autopep8 -i -r .');
                        }
                        formatCheckExecuted = true;
                    } catch (error2) {
                        warnings.push('No Python formatter found (black or autopep8)');
                    }
                }
            }
        }
        
        if (!formatCheckExecuted) {
            warnings.push('No formatting tools found. Supported: prettier, eslint, gofmt, rustfmt, black, autopep8');
        }
        
    } catch (error) {
        errors.push(\`Format check failed: \${error.message}\`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(\`Unexpected error during format check: \${error.message}\`);
    console.log(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'github-actions.js': `#!/usr/bin/env node
/**
 * GitHub Actions Workflow Check
 * Validates GitHub Actions workflow files
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// Simple YAML parser fallback if js-yaml is not available
function parseYAML(content) {
    try {
        return yaml.load(content);
    } catch (e) {
        // Basic validation without full parsing
        const errors = [];
        const lines = content.split('\\n');
        
        // Check for basic YAML syntax
        let indentLevel = 0;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmed = line.trim();
            
            // Skip empty lines and comments
            if (!trimmed || trimmed.startsWith('#')) continue;
            
            // Check for tabs (YAML doesn't allow tabs)
            if (line.includes('\\t')) {
                errors.push(\`Line \${i + 1}: YAML files should not contain tabs\`);
            }
            
            // Check for proper key-value format
            if (trimmed.includes(':') && !trimmed.match(/^[\\w-]+:/)) {
                const beforeColon = trimmed.split(':')[0];
                if (beforeColon.includes(' ') && !beforeColon.startsWith('"') && !beforeColon.startsWith("'")) {
                    errors.push(\`Line \${i + 1}: Keys with spaces must be quoted\`);
                }
            }
        }
        
        if (errors.length > 0) {
            throw new Error(errors.join('; '));
        }
        
        return null; // Can't fully parse, but no obvious errors
    }
}

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const workflowsDir = path.join(process.cwd(), '.github', 'workflows');
        
        if (!fs.existsSync(workflowsDir)) {
            warnings.push('No .github/workflows directory found');
            console.log(JSON.stringify({
                passed: true,
                errors: errors,
                warnings: warnings
            }, null, 2));
            return;
        }
        
        const files = fs.readdirSync(workflowsDir);
        const workflowFiles = files.filter(f => f.endsWith('.yml') || f.endsWith('.yaml'));
        
        if (workflowFiles.length === 0) {
            warnings.push('No workflow files found in .github/workflows');
        }
        
        for (const file of workflowFiles) {
            const filePath = path.join(workflowsDir, file);
            const content = fs.readFileSync(filePath, 'utf8');
            
            try {
                const workflow = parseYAML(content);
                
                if (workflow) {
                    // Validate workflow structure
                    if (!workflow.name) {
                        warnings.push(\`\${file}: Missing 'name' field\`);
                    }
                    
                    if (!workflow.on) {
                        errors.push(\`\${file}: Missing 'on' trigger definition\`);
                    }
                    
                    if (!workflow.jobs || Object.keys(workflow.jobs).length === 0) {
                        errors.push(\`\${file}: No jobs defined\`);
                    }
                    
                    // Check for deprecated actions
                    const workflowString = JSON.stringify(workflow);
                    const deprecatedActions = [
                        { pattern: 'actions/setup-node@v1', replacement: 'actions/setup-node@v4' },
                        { pattern: 'actions/checkout@v1', replacement: 'actions/checkout@v4' },
                        { pattern: 'actions/checkout@v2', replacement: 'actions/checkout@v4' },
                        { pattern: 'actions/setup-python@v1', replacement: 'actions/setup-python@v4' },
                        { pattern: 'actions/cache@v1', replacement: 'actions/cache@v3' }
                    ];
                    
                    for (const { pattern, replacement } of deprecatedActions) {
                        if (workflowString.includes(pattern)) {
                            warnings.push(\`\${file}: Deprecated action '\${pattern}' - use '\${replacement}'\`);
                        }
                    }
                    
                    // Check each job
                    if (workflow.jobs) {
                        for (const [jobName, job] of Object.entries(workflow.jobs)) {
                            if (!job['runs-on']) {
                                errors.push(\`\${file}: Job '\${jobName}' missing 'runs-on'\`);
                            }
                            
                            if (!job.steps || job.steps.length === 0) {
                                errors.push(\`\${file}: Job '\${jobName}' has no steps\`);
                            }
                            
                            // Check for hardcoded secrets
                            const jobString = JSON.stringify(job);
                            if (jobString.match(/['\`"][A-Za-z0-9]{20,}['\`"]/)) {
                                warnings.push(\`\${file}: Possible hardcoded secret in job '\${jobName}'\`);
                            }
                        }
                    }
                }
            } catch (parseError) {
                errors.push(\`\${file}: Invalid YAML - \${parseError.message}\`);
            }
        }
        
    } catch (error) {
        errors.push(\`GitHub Actions check failed: \${error.message}\`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Try to load js-yaml, but continue without it if not available
let yaml;
try {
    yaml = require('js-yaml');
} catch (e) {
    // Will use fallback parser
}

// Run the check
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'tdd-automation.js': TDD_AUTOMATION_SCRIPT,
    'ai-code-review.js': AI_CODE_REVIEW_SCRIPT,
    'doc-generator.js': DOC_GENERATOR_SCRIPT
};

export const DEFAULT_CONFIG = {
    scripts: [
        {
            id: "production-readiness",
            name: "Production Readiness Check",
            description: "Checks for TODO, FIXME, placeholders, and incomplete implementations",
            enabled: true,
            order: 1
        },
        {
            id: "build-check",
            name: "Build Check",
            description: "Verifies that the project builds successfully",
            enabled: true,
            order: 2
        },
        {
            id: "test-check",
            name: "Test Check",
            description: "Runs tests to ensure they all pass",
            enabled: true,
            order: 3
        },
        {
            id: "format-check",
            name: "Format Check",
            description: "Ensures code is properly formatted",
            enabled: true,
            order: 4
        },
        {
            id: "github-actions",
            name: "GitHub Actions Check",
            description: "Validates GitHub Actions workflows",
            enabled: true,
            order: 5
        },
        {
            id: "tdd-automation",
            name: "TDD Automation",
            description: "Ensures test coverage and test-driven development",
            enabled: true,
            order: 6
        },
        {
            id: "ai-code-review",
            name: "AI Code Review",
            description: "AI-powered code quality, security, and performance review",
            enabled: true,
            order: 7
        },
        {
            id: "doc-generator",
            name: "Documentation Check",
            description: "Checks for missing documentation and generates suggestions",
            enabled: true,
            order: 8
        }
    ],
    maxIterations: 5
};

export const SCRIPTS_README = `# Claude Autopilot Scripts

This folder contains quality check scripts that ensure your code meets production standards.

## Built-in Scripts

1. **production-readiness.js** - Scans for TODO, FIXME, placeholders, and incomplete implementations
2. **build-check.js** - Verifies that your project builds successfully  
3. **test-check.js** - Runs your test suite and ensures all tests pass
4. **format-check.js** - Checks code formatting using project-specific tools
5. **github-actions.js** - Validates GitHub Actions workflow files
6. **tdd-automation.js** - Ensures test coverage and test-driven development
7. **ai-code-review.js** - AI-powered code quality, security, and performance review
8. **doc-generator.js** - Checks for missing documentation and generates suggestions

## Custom Scripts

You can add your own validation scripts to this folder. Scripts should:

1. Be executable (chmod +x)
2. Return JSON output with this format:
   \`\`\`json
   {
     "passed": true/false,
     "errors": ["error1", "error2"],
     "warnings": ["warning1", "warning2"]
   }
   \`\`\`
3. Exit with code 0 on success, non-zero on failure

## Configuration

Scripts are configured in the \`config.json\` file in the parent directory.
`;
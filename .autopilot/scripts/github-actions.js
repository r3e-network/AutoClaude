#!/usr/bin/env node
/**
 * GitHub Actions Check
 * Validates GitHub Actions workflows
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const projectRoot = process.cwd();
        const workflowsDir = path.join(projectRoot, '.github', 'workflows');
        
        if (!fs.existsSync(workflowsDir)) {
            warnings.push('No GitHub Actions workflows found (.github/workflows directory missing)');
            return {
                passed: true,
                errors,
                warnings
            };
        }
        
        // Get all workflow files
        const workflowFiles = fs.readdirSync(workflowsDir).filter(f => 
            f.endsWith('.yml') || f.endsWith('.yaml')
        );
        
        if (workflowFiles.length === 0) {
            warnings.push('No workflow files found in .github/workflows');
            return {
                passed: true,
                errors,
                warnings
            };
        }
        
        console.error(`Found ${workflowFiles.length} workflow file(s)`);
        
        // Check each workflow file
        for (const workflowFile of workflowFiles) {
            const workflowPath = path.join(workflowsDir, workflowFile);
            console.error(`Checking ${workflowFile}...`);
            
            try {
                const content = fs.readFileSync(workflowPath, 'utf8');
                
                // Basic structure validation
                if (content.trim() === '') {
                    errors.push(`${workflowFile}: Empty workflow file`);
                    continue;
                }
                
                // Check for required top-level keys
                if (!content.includes('name:')) {
                    warnings.push(`${workflowFile}: Missing 'name' field (recommended for clarity)`);
                }
                
                if (!content.includes('on:')) {
                    errors.push(`${workflowFile}: Missing 'on' trigger - workflow will never run`);
                }
                
                if (!content.includes('jobs:')) {
                    errors.push(`${workflowFile}: Missing 'jobs' section - no jobs defined`);
                }
                
                // Check for common syntax errors
                const lines = content.split('\n');
                let inString = false;
                let indentStack = [0];
                
                lines.forEach((line, index) => {
                    const lineNum = index + 1;
                    const trimmedLine = line.trim();
                    
                    // Skip empty lines and comments
                    if (!trimmedLine || trimmedLine.startsWith('#')) return;
                    
                    // Check for tabs (YAML requires spaces)
                    if (line.includes('\t')) {
                        errors.push(`${workflowFile}:${lineNum} - Contains tabs (YAML requires spaces)`);
                    }
                    
                    // Check for trailing whitespace
                    if (line !== line.trimEnd()) {
                        warnings.push(`${workflowFile}:${lineNum} - Trailing whitespace`);
                    }
                    
                    // Basic string detection for quotes
                    const quotes = (line.match(/['"]/g) || []).length;
                    if (quotes % 2 !== 0) {
                        inString = !inString;
                    }
                });
                
                // Check for deprecated actions
                const deprecatedActions = [
                    { pattern: /actions\/setup-node@v1/g, replacement: 'actions/setup-node@v4' },
                    { pattern: /actions\/checkout@v1/g, replacement: 'actions/checkout@v4' },
                    { pattern: /actions\/checkout@v2/g, replacement: 'actions/checkout@v4' },
                    { pattern: /actions\/setup-node@v2/g, replacement: 'actions/setup-node@v4' },
                    { pattern: /actions\/cache@v1/g, replacement: 'actions/cache@v3' },
                    { pattern: /actions\/upload-artifact@v1/g, replacement: 'actions/upload-artifact@v3' },
                    { pattern: /actions\/download-artifact@v1/g, replacement: 'actions/download-artifact@v3' },
                    { pattern: /actions\/create-release@v1/g, replacement: 'Use GitHub CLI (gh) instead' },
                    { pattern: /actions\/upload-release-asset@v1/g, replacement: 'Use GitHub CLI (gh) instead' }
                ];
                
                deprecatedActions.forEach(({ pattern, replacement }) => {
                    if (pattern.test(content)) {
                        const matches = content.match(pattern);
                        const actionName = matches[0];
                        warnings.push(`${workflowFile}: Deprecated action '${actionName}' - use '${replacement}'`);
                    }
                });
                
                // Check for insecure patterns
                if (content.includes('${{ github.event.pull_request.title }}') || 
                    content.includes('${{ github.event.pull_request.body }}') ||
                    content.includes('${{ github.event.issue.title }}') ||
                    content.includes('${{ github.event.issue.body }}')) {
                    warnings.push(`${workflowFile}: Potentially unsafe user input in workflow - could lead to script injection`);
                }
                
                // Check for missing permissions
                if (content.includes('GITHUB_TOKEN') && !content.includes('permissions:')) {
                    warnings.push(`${workflowFile}: Uses GITHUB_TOKEN but no 'permissions' specified - using default permissions`);
                }
                
                // Try actionlint if available
                try {
                    execSync(`actionlint ${workflowPath}`, { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8'
                    });
                } catch (error) {
                    const errorOutput = error.stderr || error.stdout || '';
                    
                    if (errorOutput.includes('command not found') || errorOutput.includes('not recognized')) {
                        // actionlint not installed - try basic YAML validation
                        try {
                            // Try to parse YAML with Node.js
                            execSync(`node -e "const yaml = require('js-yaml'); yaml.load(require('fs').readFileSync('${workflowPath}', 'utf8'));"`, {
                                stdio: 'ignore'
                            });
                        } catch (yamlError) {
                            errors.push(`${workflowFile}: Invalid YAML syntax`);
                        }
                    } else if (errorOutput) {
                        // actionlint found issues
                        const actionlintErrors = errorOutput.split('\n').filter(line => line.trim());
                        actionlintErrors.forEach(error => {
                            if (error.includes(workflowPath)) {
                                // Extract just the relevant part after the filename
                                const errorMessage = error.split(workflowPath)[1] || error;
                                errors.push(`${workflowFile}${errorMessage}`);
                            } else if (!error.includes('actionlint: not found')) {
                                errors.push(`${workflowFile}: ${error}`);
                            }
                        });
                    }
                }
                
                // Check for workflow-specific issues
                
                // Check if workflow uses matrix but doesn't define it
                if (content.includes('${{ matrix.') && !content.includes('matrix:')) {
                    errors.push(`${workflowFile}: References matrix variables but no matrix strategy defined`);
                }
                
                // Check for common job issues
                const jobMatches = content.match(/^\s{2}[\w-]+:/gm) || [];
                if (jobMatches.length === 0 && content.includes('jobs:')) {
                    errors.push(`${workflowFile}: 'jobs' section exists but no jobs defined`);
                }
                
                // Check for invalid cron syntax
                const cronMatches = content.match(/cron:\s*['"]([^'"]+)['"]/g) || [];
                cronMatches.forEach(match => {
                    const cron = match.match(/['"]([^'"]+)['"]/)[1];
                    const cronParts = cron.split(' ');
                    if (cronParts.length !== 5) {
                        errors.push(`${workflowFile}: Invalid cron expression '${cron}' - must have 5 fields`);
                    }
                });
                
            } catch (error) {
                errors.push(`${workflowFile}: Failed to read or parse - ${error.message}`);
            }
        }
        
        // Additional checks for workflow best practices
        const readmeExists = fs.existsSync(path.join(projectRoot, 'README.md'));
        if (readmeExists) {
            try {
                const readme = fs.readFileSync(path.join(projectRoot, 'README.md'), 'utf8');
                const hasBadges = workflowFiles.some(file => {
                    const workflowName = file.replace(/\.(yml|yaml)$/, '');
                    return readme.includes(`${workflowName}/badge.svg`) || 
                           readme.includes('actions/workflows/');
                });
                
                if (workflowFiles.length > 0 && !hasBadges) {
                    warnings.push('Consider adding GitHub Actions status badges to README.md');
                }
            } catch (error) {
                // Ignore README read errors
            }
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [`Script execution failed: ${error.message}`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});
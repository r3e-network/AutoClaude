#!/usr/bin/env node
/**
 * Production Readiness Check
 * Checks for TODO, FIXME, placeholders, and incomplete implementations
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Patterns that indicate incomplete or non-production code
        const patterns = [
            { pattern: /TODO/gi, message: 'TODO comment found' },
            { pattern: /FIXME/gi, message: 'FIXME comment found' },
            { pattern: /PLACEHOLDER/gi, message: 'Placeholder found' },
            { pattern: /XXX/gi, message: 'XXX marker found' },
            { pattern: /HACK/gi, message: 'HACK comment found' },
            { pattern: /temporary/gi, message: 'Temporary code found' },
            { pattern: /quick\s+fix/gi, message: 'Quick fix found' },
            { pattern: /for\s+now/gi, message: '"for now" comment found' },
            { pattern: /simplified/gi, message: 'Simplified implementation found' },
            { pattern: /\.\.\./, message: 'Ellipsis (...) found - possible incomplete code' },
            { pattern: /<<<|>>>/, message: 'Merge conflict markers found' },
            { pattern: /not\s+implemented/gi, message: 'Not implemented found' },
            { pattern: /throw\s+new\s+Error\(['"`]not\s+implemented/gi, message: 'Not implemented error found' },
            { pattern: /console\.(log|debug|trace)/g, message: 'Debug console statement found' },
            { pattern: /debugger;/g, message: 'Debugger statement found' }
        ];
        
        // File extensions to check
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.go', '.cpp', '.cc', '.h', '.hpp', '.rs', '.cs', '.java', '.py', '.rb', '.php', '.swift', '.kt', '.scala', '.vue', '.svelte'];
        
        // Directories to skip
        const skipDirs = ['.git', 'node_modules', 'dist', 'build', 'out', 'target', 'bin', 'obj', '.next', '.nuxt', 'coverage', '.nyc_output', 'vendor', '.autopilot'];
        
        function scanDirectory(dir) {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!skipDirs.includes(file) && !file.startsWith('.')) {
                        scanDirectory(filePath);
                    }
                } else if (stat.isFile() && extensions.includes(path.extname(file).toLowerCase())) {
                    try {
                        const content = fs.readFileSync(filePath, 'utf8');
                        const lines = content.split('\n');
                        
                        lines.forEach((line, index) => {
                            patterns.forEach(({ pattern, message }) => {
                                const match = line.match(pattern);
                                if (match) {
                                    const relPath = path.relative(process.cwd(), filePath);
                                    errors.push(`${relPath}:${index + 1} - ${message}: "${match[0]}"`);
                                }
                            });
                        });
                    } catch (err) {
                        // Skip files that can't be read
                        if (err.code !== 'ENOENT' && err.code !== 'EISDIR') {
                            warnings.push(`Could not read ${filePath}: ${err.message}`);
                        }
                    }
                }
            }
        }
        
        // Start scanning from current directory
        scanDirectory(process.cwd());
        
        // Check for common incomplete patterns in specific files
        const packageJsonPath = path.join(process.cwd(), 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for common development dependencies in production
                const devDepsInMain = ['nodemon', 'jest', 'mocha', 'chai', 'sinon', 'eslint', 'prettier'];
                if (pkg.dependencies) {
                    devDepsInMain.forEach(dep => {
                        if (pkg.dependencies[dep]) {
                            warnings.push(`Development dependency "${dep}" found in production dependencies`);
                        }
                    });
                }
                
                // Check for missing important fields
                if (!pkg.description || pkg.description.trim() === '') {
                    warnings.push('package.json missing description');
                }
                if (!pkg.repository) {
                    warnings.push('package.json missing repository information');
                }
                if (!pkg.license) {
                    warnings.push('package.json missing license');
                }
            } catch (err) {
                warnings.push(`Could not parse package.json: ${err.message}`);
            }
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [`Script execution failed: ${error.message}`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});
#!/usr/bin/env node
/**
 * Format Check
 * Ensures code is properly formatted
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Detect project type and check formatting
        const projectRoot = process.cwd();
        let formatCheckExecuted = false;
        
        // Node.js / JavaScript / TypeScript
        const packageJsonPath = path.join(projectRoot, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for lint/format scripts
                if (pkg.scripts) {
                    if (pkg.scripts.lint) {
                        try {
                            console.error('Running npm lint...');
                            execSync('npm run lint', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(`Linting failed: ${errorOutput}`);
                            formatCheckExecuted = true;
                        }
                    } else if (pkg.scripts.format && pkg.scripts['format:check']) {
                        // Some projects have separate format:check script
                        try {
                            console.error('Running format check...');
                            execSync('npm run format:check', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(`Format check failed: ${errorOutput}`);
                            formatCheckExecuted = true;
                        }
                    }
                }
                
                // If no scripts, check for tools directly
                if (!formatCheckExecuted) {
                    // Prettier
                    const hasPrettier = pkg.devDependencies?.prettier || pkg.dependencies?.prettier;
                    if (hasPrettier || fs.existsSync(path.join(projectRoot, '.prettierrc')) || 
                        fs.existsSync(path.join(projectRoot, '.prettierrc.json')) ||
                        fs.existsSync(path.join(projectRoot, '.prettierrc.js')) ||
                        fs.existsSync(path.join(projectRoot, 'prettier.config.js'))) {
                        try {
                            console.error('Running Prettier check...');
                            execSync('npx prettier --check .', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            if (errorOutput.includes('files were not formatted')) {
                                const unformattedFiles = errorOutput.match(/\[warn\] (.+)/g) || [];
                                errors.push(`Prettier: ${unformattedFiles.length} file(s) not formatted`);
                                unformattedFiles.slice(0, 10).forEach(file => {
                                    errors.push(file.replace('[warn] ', '  - '));
                                });
                                if (unformattedFiles.length > 10) {
                                    errors.push(`  ... and ${unformattedFiles.length - 10} more files`);
                                }
                            } else {
                                errors.push(`Prettier check failed: ${errorOutput}`);
                            }
                            formatCheckExecuted = true;
                        }
                    }
                    
                    // ESLint
                    const hasEslint = pkg.devDependencies?.eslint || pkg.dependencies?.eslint;
                    if (!formatCheckExecuted && (hasEslint || fs.existsSync(path.join(projectRoot, '.eslintrc')) ||
                        fs.existsSync(path.join(projectRoot, '.eslintrc.json')) ||
                        fs.existsSync(path.join(projectRoot, '.eslintrc.js')))) {
                        try {
                            console.error('Running ESLint...');
                            execSync('npx eslint .', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(`ESLint found issues: ${errorOutput}`);
                            formatCheckExecuted = true;
                        }
                    }
                    
                    // StandardJS
                    const hasStandard = pkg.devDependencies?.standard || pkg.dependencies?.standard;
                    if (!formatCheckExecuted && hasStandard) {
                        try {
                            console.error('Running StandardJS...');
                            execSync('npx standard', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(`StandardJS found issues: ${errorOutput}`);
                            formatCheckExecuted = true;
                        }
                    }
                }
                
                if (!formatCheckExecuted && (pkg.devDependencies || pkg.dependencies)) {
                    const deps = { ...pkg.devDependencies, ...pkg.dependencies };
                    if (deps.eslint || deps.prettier || deps.standard || deps.tslint) {
                        warnings.push('Formatting tools found in dependencies but no lint/format script configured');
                    }
                }
            } catch (error) {
                warnings.push(`Could not parse package.json: ${error.message}`);
            }
        }
        
        // Go
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'go.mod'))) {
            try {
                console.error('Running gofmt check...');
                const output = execSync('gofmt -l .', { encoding: 'utf8' });
                
                if (output.trim()) {
                    const files = output.trim().split('\n');
                    errors.push(`gofmt: ${files.length} file(s) not formatted:`);
                    files.slice(0, 10).forEach(file => {
                        errors.push(`  - ${file}`);
                    });
                    if (files.length > 10) {
                        errors.push(`  ... and ${files.length - 10} more files`);
                    }
                } else {
                    formatCheckExecuted = true;
                }
            } catch (error) {
                warnings.push(`gofmt check failed: ${error.message}`);
            }
            
            // Also check go vet
            if (!errors.length) {
                try {
                    console.error('Running go vet...');
                    execSync('go vet ./...', { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8'
                    });
                } catch (error) {
                    const errorOutput = error.stderr || error.message;
                    warnings.push(`go vet found issues: ${errorOutput}`);
                }
            }
            formatCheckExecuted = true;
        }
        
        // Rust
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            try {
                console.error('Running rustfmt check...');
                execSync('cargo fmt -- --check', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                if (errorOutput.includes('Diff in')) {
                    errors.push('rustfmt: Some files need formatting. Run "cargo fmt" to fix.');
                } else {
                    errors.push(`rustfmt check failed: ${errorOutput}`);
                }
                formatCheckExecuted = true;
            }
            
            // Also run clippy if available
            try {
                console.error('Running clippy...');
                execSync('cargo clippy -- -D warnings', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
            } catch (error) {
                warnings.push('Clippy found warnings or is not installed');
            }
        }
        
        // Python
        if (!formatCheckExecuted && (fs.existsSync(path.join(projectRoot, 'setup.py')) || 
                                     fs.existsSync(path.join(projectRoot, 'pyproject.toml')) ||
                                     fs.existsSync(path.join(projectRoot, 'requirements.txt')))) {
            // Black
            try {
                console.error('Running black check...');
                execSync('python -m black --check .', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.stdout || error.message;
                if (errorOutput.includes('would be reformatted') || errorOutput.includes('would reformat')) {
                    const match = errorOutput.match(/(\d+) file/);
                    const fileCount = match ? match[1] : 'Some';
                    errors.push(`Black: ${fileCount} file(s) would be reformatted`);
                    formatCheckExecuted = true;
                } else if (!errorOutput.includes('command not found') && !errorOutput.includes('No module named')) {
                    errors.push(`Black check failed: ${errorOutput}`);
                    formatCheckExecuted = true;
                }
            }
            
            // Flake8
            if (!formatCheckExecuted) {
                try {
                    console.error('Running flake8...');
                    execSync('python -m flake8 .', { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8'
                    });
                    formatCheckExecuted = true;
                } catch (error) {
                    const errorOutput = error.stderr || error.stdout || error.message;
                    if (!errorOutput.includes('command not found') && !errorOutput.includes('No module named')) {
                        errors.push(`Flake8 found issues: ${errorOutput}`);
                        formatCheckExecuted = true;
                    }
                }
            }
            
            // Pylint
            if (!formatCheckExecuted) {
                try {
                    console.error('Running pylint...');
                    execSync('python -m pylint **/*.py', { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8',
                        shell: true
                    });
                    formatCheckExecuted = true;
                } catch (error) {
                    const errorOutput = error.stderr || error.stdout || error.message;
                    if (!errorOutput.includes('command not found') && !errorOutput.includes('No module named')) {
                        warnings.push('Pylint found issues or is not configured');
                        formatCheckExecuted = true;
                    }
                }
            }
            
            if (!formatCheckExecuted) {
                warnings.push('Python project detected but no formatter (black/flake8/pylint) available');
            }
        }
        
        // C# / .NET
        if (!formatCheckExecuted && (fs.readdirSync(projectRoot).some(f => f.endsWith('.csproj')))) {
            try {
                console.error('Running dotnet format check...');
                execSync('dotnet format --verify-no-changes', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                if (errorOutput.includes('code changes were made')) {
                    errors.push('dotnet format: Code formatting changes needed');
                } else {
                    warnings.push('dotnet format not available or project not formatted');
                }
                formatCheckExecuted = true;
            }
        }
        
        // Java - Checkstyle/Spotless
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            // Check if spotless is configured
            try {
                const pomContent = fs.readFileSync(path.join(projectRoot, 'pom.xml'), 'utf8');
                if (pomContent.includes('spotless-maven-plugin')) {
                    try {
                        console.error('Running spotless check...');
                        execSync('mvn spotless:check', { 
                            stdio: ['ignore', 'ignore', 'pipe'],
                            encoding: 'utf8'
                        });
                        formatCheckExecuted = true;
                    } catch (error) {
                        errors.push('Spotless: Code formatting changes needed. Run "mvn spotless:apply" to fix.');
                        formatCheckExecuted = true;
                    }
                }
            } catch (error) {
                // Ignore
            }
        }
        
        // Ruby - RuboCop
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'Gemfile'))) {
            try {
                console.error('Running RuboCop...');
                execSync('bundle exec rubocop', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.stdout || error.message;
                if (errorOutput.includes('offenses detected')) {
                    errors.push('RuboCop: Style violations detected');
                    formatCheckExecuted = true;
                }
            }
        }
        
        if (!formatCheckExecuted) {
            warnings.push('No recognized code formatter found. Supported: prettier, eslint, standard, gofmt, rustfmt, black, flake8, dotnet format, spotless, rubocop');
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [`Script execution failed: ${error.message}`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});
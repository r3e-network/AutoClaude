#!/usr/bin/env node
/**
 * Build Check
 * Ensures the project can build successfully
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Detect project type and run appropriate build command
        const projectRoot = process.cwd();
        let buildExecuted = false;
        
        // Node.js / JavaScript / TypeScript
        const packageJsonPath = path.join(projectRoot, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for build script
                if (pkg.scripts && pkg.scripts.build) {
                    try {
                        console.error('Running npm build...');
                        execSync('npm run build', { 
                            stdio: ['ignore', 'ignore', 'pipe'],
                            encoding: 'utf8'
                        });
                        buildExecuted = true;
                    } catch (error) {
                        const errorOutput = error.stderr || error.message;
                        errors.push(`npm build failed: ${errorOutput}`);
                        buildExecuted = true;
                    }
                } else if (pkg.scripts && pkg.scripts.compile) {
                    // Some projects use 'compile' instead of 'build'
                    try {
                        console.error('Running npm compile...');
                        execSync('npm run compile', { 
                            stdio: ['ignore', 'ignore', 'pipe'],
                            encoding: 'utf8'
                        });
                        buildExecuted = true;
                    } catch (error) {
                        const errorOutput = error.stderr || error.message;
                        errors.push(`npm compile failed: ${errorOutput}`);
                        buildExecuted = true;
                    }
                } else {
                    // Check if it's a TypeScript project without build script
                    if (fs.existsSync(path.join(projectRoot, 'tsconfig.json'))) {
                        try {
                            console.error('Running TypeScript compiler...');
                            execSync('npx tsc --noEmit', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            buildExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.message;
                            errors.push(`TypeScript compilation failed: ${errorOutput}`);
                            buildExecuted = true;
                        }
                    } else {
                        warnings.push('No build script found in package.json');
                    }
                }
            } catch (error) {
                warnings.push(`Could not parse package.json: ${error.message}`);
            }
        }
        
        // Go
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'go.mod'))) {
            try {
                console.error('Running go build...');
                execSync('go build ./...', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`Go build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        // Rust
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            try {
                console.error('Running cargo build...');
                execSync('cargo build', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`Cargo build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        // C# / .NET
        const csprojFiles = fs.readdirSync(projectRoot).filter(f => f.endsWith('.csproj'));
        const slnFiles = fs.readdirSync(projectRoot).filter(f => f.endsWith('.sln'));
        if (!buildExecuted && (csprojFiles.length > 0 || slnFiles.length > 0)) {
            try {
                console.error('Running dotnet build...');
                execSync('dotnet build', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`Dotnet build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        // Java - Maven
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            try {
                console.error('Running maven compile...');
                execSync('mvn compile', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`Maven build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        // Java - Gradle
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, 'build.gradle')) || 
                               fs.existsSync(path.join(projectRoot, 'build.gradle.kts')))) {
            try {
                console.error('Running gradle build...');
                const gradleWrapper = fs.existsSync(path.join(projectRoot, 'gradlew')) ? './gradlew' : 'gradle';
                execSync(`${gradleWrapper} build`, { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`Gradle build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        // Python - setup.py
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'setup.py'))) {
            try {
                console.error('Checking Python setup...');
                execSync('python setup.py check', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                warnings.push(`Python setup check failed: ${errorOutput}`);
                // Don't count as error since many Python projects don't need building
            }
        }
        
        // C/C++ with Make
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, 'Makefile')) || 
                               fs.existsSync(path.join(projectRoot, 'makefile')))) {
            try {
                console.error('Running make...');
                execSync('make', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`Make build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        // C/C++ with CMake
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'CMakeLists.txt'))) {
            try {
                console.error('Running cmake build...');
                if (!fs.existsSync('build')) {
                    execSync('cmake -B build', { stdio: 'ignore' });
                }
                execSync('cmake --build build', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(`CMake build failed: ${errorOutput}`);
                buildExecuted = true;
            }
        }
        
        if (!buildExecuted) {
            warnings.push('No recognized build system found. Supported: npm, go, cargo, dotnet, maven, gradle, make, cmake');
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [`Script execution failed: ${error.message}`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});